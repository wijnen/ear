#!/usr/bin/python3
# vim: set foldmethod=marker :

# Imports. {{{

import fhs
config = fhs.init({"webUI":True, 'gtkUI':False })

from collections import OrderedDict
import gi
gi.require_version('GLib', '2.0')
from gi.repository import GLib
import os
import media
import dbread
import zmq
import simplejson.scanner
import subprocess
#}}}

def file_new(dummy = None):
    db.append(Track('', data['track'].dbname if data['track'] else fhs.write_data(os.path.join('db', 'default' + os.extsep + 'db'), opened = False)))
    g.update_files = True
    data['track'] = db[-1]
    new_file()

def new_file():
    if len(data['track']['files']) > 0:
        data['media'].load(data['track'], 0)
        print("Loading track")
    else:
        print("Empty track")
        data['media'].load(data['track'], None)
        g.length = (0, 1)
    g.position = 0
    g.load_markers = True
    g.set_player = True
    if data['track']['media'] is not None:
        set_pos(data['track']['files'][data['track']['media']][1])
    g.media_list = [x[0] for x in data['track']['files']]
    g.media = 0

setting_pos = False
def set_pos(pos):
    global setting_pos
    g.status = media.mkmomentstr(pos)
    setting_pos = True
    g.position = pos
    setting_pos = False
    if not data['track']:
        return
    return

def stop(stopped):
    g.playing = not stopped
    data['media'].play(cb = None, start = 0) #Essential to clear the callback
    set_pos(0) 
    data['media'].pause(stopped)

def save_all():
    dbread.write(db)

db = dbread.read()
data = {
    'db': db,
    'track': None,
    'tag': '',
    'media': media.Media(set_pos, lambda min, max: setattr(g, 'offset_range', (min, max)), lambda p: setattr(g, 'marker_endtarget', p)),
    'playing': lambda x: setattr(g, 'playing', x),
    'position': lambda pos: setattr(g, 'position', pos),
    }
data['media'].send_pixbuf = lambda pixbuf: setattr(g, 'image', pixbuf)

def play_list(track, play_tuple):
    track.play(cb = None) #Essential to clear the callback
    if len(play_tuple) < 1:
        return
    start, end = play_tuple[0][0], play_tuple[0][1]
    if len(play_tuple[1:])>0: 
        track.play(start, end, play = True, cb = lambda : play_list(track, play_tuple[1:]))
    else:
        track.play(start, end, play = True, cb = None)

kwargs = { 'data' : data ,
        'events' : {
            #'pause': lambda: data['media'].pause(not data['media'].playing()),
            'pause': lambda: data['media'].pause(data['media'].playing()),
            'save_all': save_all,
            'stop': lambda x: stop(True),
            'continue': lambda x: stop(False), #Right now, this means play_from_start, and clicking pause again continues
        },
        }

class State():
    def __init__(self,*args,**kwargs):
        self._add(**kwargs)
    def _add(self,**kwargs):
     for k,v in kwargs:
        if type(v) == dict:
            self._add(self,v)
        else:
            setattr(self,k,v)


g = State(kwargs) 
"""Set defaults"""
g.speed = 100
g.volume = 100
g.before = 3
#
       

zmqcontext=zmq.Context()
zmq_socket=zmqcontext.socket(zmq.REP)
zmq_socket.bind("tcp://*:5555")
zmq_fd=zmq_socket.getsockopt(zmq.FD)
g.before_active = True
def zmq_callback(fd,condition,zmq_socket):
    while zmq_socket.getsockopt(zmq.EVENTS) & zmq.POLLIN:
        wt = False
        try:
            msg = zmq_socket.recv_json()
        except simplejson.scanner.JSONDecodeError as e:
            print(e)
            zmq_socket.send_string("something recieved, please send json")
            continue
        except Exception as e:
            print(msg)
            print(e)
            continue
        if type(msg) == dict:
            if 'play' in msg.keys() and type(msg['play'])==list:
                play_list(data['media'], msg['play'])
                zmq_socket.send_json({"dummy":"dummy"})
            if 'fragments' in msg.keys() and type(msg['fragments'])==list:
                data['track']['fragments'] = msg['fragments'][2] #In Wt, we need a single root. This is called 'fragments' and only has children. Children are stored in idx 2
                data['track']['dirty'] = True
                zmq_socket.send_json({'_':'_'})
        if type(msg) == list:
            if len(msg) ==1:
                msg=msg[0]
        if type(msg)==str:
            if msg =="events?":
                #The Wt JSON parser needs to know if stuff is a dict or a list before parsing (otherwise you can't assign to an Array or Object. That's why _EVERYTHING_ is a dict. We might use the second argument to describe the text on the widget instead of using the command name for that.
                nevents = ["stop","save_all"] #Maybe just move these last two names to Wt as well?
                events = OrderedDict ( [(k,None) for k in nevents ])
                zmq_socket.send_json(events)
            elif msg.startswith('event:'):
                event=msg[len('event:'):]
                print ("Event:{}".format(event))
                if event in kwargs['events'].keys():
                    try:
                        ret=kwargs['events'][event]("foo")
                    except TypeError:
                        ret=kwargs['events'][event]()
                    if ret ==None:
                        ret=="None"
                    zmq_socket.send_json({"ret":ret})   
                elif event == "play":
                    g.playing = True
                    data['media'].play()
                    zmq_socket.send_json({"state":g.playing}) 
                else:
                    zmq_socket.send_json("No such event")
                    print("No such event")
            elif msg =="inputs?":
                inputs = {"speed":[50,200],"before":[0,10]} #Needs volume as well at some point (min,max)
                for inp in inputs.keys():
                    inputs[inp].append(getattr(g,inp))
                zmq_socket.send_json(inputs)
            elif msg.startswith("input:"):
                _,inp,val=msg.split(":")
                try:
                    val=float(val)
                except ValueError as e:
                    print(e)
                    continue
                setattr(g,inp,val)
                if inp == "speed":
                    data['media'].set_speed(val / 100.)
                zmq_socket.send_json({"dummy":"dummy"})
            elif msg =="track?":
                if not data['track']:
                    zmq_socket.send_json({"current":-1})
                else:
                    zmq_socket.send_json({"current":db.index(data['track'])})
            elif msg =="tracks?":
                out = OrderedDict()
                for x,track in enumerate(db):
                    if len(track['tags']) == 0:
                        track['tags'].append("")
                    out[track['name']] = [x]+track['tags'] #track index is very much needed in the Wt UI!
                zmq_socket.send_json({'tracks': out})
            elif msg.startswith('track:'):
                select=msg[len('track:'):]
                try:
                    sel = int(select)
                except ValueError as e:
                    print (e)
                    continue
                data['track']=db[sel]    
                new_file()
                zmq_socket.send_json({"dummy":"dummy"})
            elif msg == "fragments?":
                if not data['track']:
                    zmq_socket.send_json({"fragments":[]})
                    continue
                zmq_socket.send_json({"fragments":data['track']['fragments']})
            elif msg =="markers?":
                if not data['track']:
                    zmq_socket.send_json({"markers":[]})
                    continue
                sendMarkers=[]
                for marker in data["track"]['fragments']:
                    sendMarkers.append({"name":marker.name, "start":marker.start})
                zmq_socket.send_json({"markers":sendMarkers})
            elif msg.startswith("play:"): 
                try:
                    startTime=float(msg[len("play:"):])
                except Exception as e:
                    zmq_socket.send_json({"dummy":"dummy"})
                    print(e)
                    continue
                zmq_socket.send_json({"dummy":"dummy"})
                data['media'].play(startTime, play = True)
            elif msg.startswith("pos?"):
                zmq_socket.send_json({"pos":data['media'].get_pos()})
            elif msg.startswith("pos:"): 
                try:
                    npos = int(msg[len("pos:"):])
                except ValueError as e:
                    print(e)
                    continue
                set_pos(npos) 
                data['media'].play(g.position, play = None)
                zmq_socket.send_json({"pos":g.position})
            elif msg.startswith("fragments"):
                zmq_socket.send_json({"dummy":g.position})
            elif msg.startswith("playing?"):
                zmq_socket.send_json({"playing":data['media'].playing()})
            elif msg.startswith("waveform?"):
                zmq_socket.send_json({"waveform":data['media'].waveform}) #CAn be huge message 
            else:
                print ("Event not handled:{}".format(msg))
                zmq_socket.send_json({"dummy":g.position})
    return True

from gi.repository import GObject
GObject.io_add_watch(zmq_fd,GObject.IO_IN, zmq_callback, zmq_socket)

set_pos(0)
data['track']=db[-1]    
new_file()
print(data['track'])
print(data['media'])
GLib.MainLoop().run()
    
#
